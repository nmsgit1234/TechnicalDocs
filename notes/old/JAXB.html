






<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang='en'>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>Java Architecture for XML Binding (JAXB)</title>
<meta name="collection" content="reference">
<meta http-equiv="content-language" content="en">
<meta name="description" content="Overview of the JAXB API" />
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<meta name="archive" content="FALSE" />
<meta name="date" content="2003-03-22" />
<link rel="stylesheet" href="/css/default_developer.css" />
<script type='text/JavaScript' src='/js/popUp.js'></script>
</head>
<!--stopindex-->
<body leftmargin="0" topmargin="0" marginheight="0" marginwidth="0" rightmargin="0" bgcolor="#ffffff">
<a name="top"></a>
<!-- BEGIN GENERIC MASTHEAD -->
<!-- BEGIN VNV1 COMPONENT V0  -->
<script type='text/JavaScript' src='/js/showHide.js'></script>
<div class="vnv1sunlogo"><a href="http://www.sun.com"><img src="/im/vnv1_sunlogo.gif" alt="sun.com" width="55" height="24" border="0"></a></div>
<div class="vnv1" id="vnv1v0">
<div class="cornerTL"><div class="cornerTR"><div class="cornerBL"><div class="cornerBR">
<div class="vnv1search">
<table border="0" cellpadding="0" cellspacing="0" class="topnavlight">
<form name="formsearch" action="/dispatcher.jsp" method="post" accept-charset="utf-8">
<input type="hidden" name="charset" value="utf-8">
<tr>
<td nowrap="nowrap"><span class="rightarrowwhite">&raquo;</span>&nbsp;<a href="http://developers.sun.com/dispatcher.jsp?uid=6910020">search tips</a>&nbsp;</td>
<td><input class="searchfield" name="qt" class="medium" size="7" onFocus="if( this.value==this.defaultValue ) this.value='';" value="Search"></td>
<td class="selectcell"><select class="globalsearch" name="uid">
<option value="6910018" selected>in Developers' Site</option>
<option value="6910019">in Sun.com</option>
</select></td>
<td valign="middle" align="left"><input type="image" border="0" src="/im/vnv1_bttn_search.gif" alt="Submit Search"></td>
</tr></form>
</table>
</div>
<div class="vnv1topiclinks">
<table cellpadding="1" cellspacing="0" border="0">
<tr>
<td rowspan="2"><a href="http://java.sun.com" title="java.sun.com"><img src="/im/a.gif" alt="Home Page" width="96" height="58" border="0" class="sunlogo"></a></td>
<td colspan="4"><a href="http://developers.sun.com" title="developers.sun.com"><img src="/im/a.gif" alt="" width="250" height="32" border="0"></a></td>
</tr>
<tr>
<td><img src="/im/a.gif" alt="" width="1" height="1" border="0" id="ip1"></td>
<td class="navlinks" id="navlink1"><a href="http://developers.sun.com/dispatcher.jsp?uid=6910023">Products and Technologies</a></td>
<td><img src="/im/a.gif" alt="" width="1" height="1" border="0" id="ip2"></td>
<td class="navlinks" id="navlink2"><a href="http://developers.sun.com/dispatcher.jsp?uid=6910024">Technical Topics</a></td>
</tr>
</table>
</div>
</div></div></div></div>
</div>
<!-- END VNV1 COMPONENT V0  -->
<!-- END GENERIC MASTHEAD -->
<!-- BEGIN BREADCRUMB -->
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="vatop">
<tr>
<td>      
<div class="breadcrumb">
<a href="http://developers.sun.com/index.html">Developers Home</a> &gt; <a href="http://developers.sun.com/prodtech/index.html">Products & Technologies</a> &gt; <a href="http://java.sun.com/index.jsp">Java Technology</a> &gt; <a href="http://java.sun.com/webservices/index.jsp">Java Web Services</a> &gt; <a href="http://java.sun.com/webservices/reference/index.html">Reference</a> &gt; <a href="http://java.sun.com/webservices/reference/techart/index.html">Technical Articles and Tips</a> &gt; <a href="http://java.sun.com/developer/technicalArticles/WebServices/index.html">Web Services</a> &gt;
</div>
</td>
<td align="right" nowrap="nowrap"><div class="breadcrumb">
<b><a href="http://developers.sun.com/dispatcher.jsp?uid=6910021">Join Sun Developer Network</a></b><br />
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910026">Login</a> |
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910021">Register</a> | 
<a href="http://developers.sun.com/user_registration/whyregister.html">Why Register?</a>
</div></td></tr>
<tr><td colspan="2"><img src="/im/a.gif" width="770" height="1" border="0" alt=" " /></td></tr>
</table>
<span class="sp5">&nbsp;</span><br />     
<!-- END BREADCRUMB -->
<!-- BEGIN PAGETITLE -->
<div class="pagetitle2">Article</div>
<div class="pagetitle">Java Architecture for XML Binding (JAXB)</div>
<!-- END PAGETITLE -->
<!-- BEGIN WRAPPER TABLE, 2 COLUMN, MAIN/RIGHT -->
<table border="0" cellpadding="10" cellspacing="0" width="100%">
<tr><td width="100%" valign="top">
<!-- BEGIN CENTRAL COLUMN COMPONENTS -->
<!--startindex-->
<!-- ============ -->
<!-- MAIN CONTENT -->
<!-- ============ -->
<a name="skip2content"></a>
<!--  BEGIN VCD4 PFV  -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td class="smaller" valign="top"><em></em></td>
<td width="10">&nbsp;</td>
<td align="right" valign="bottom"><div class="sitelinks" style="padding:0px;">
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<td valign="bottom" align="right">&nbsp;</td>
<td valign="bottom" class="smaller" nowrap="nowrap"><a href="/jsp_utils/PrintPage.jsp" target="printFriendlyView" onclick="openPopup('','printFriendlyView',710,650,'no',1,1,0,0,0,0); return true;"><img src="/im/ic_print.gif" width="14" height="12" alt="Print-friendly Version" border="0" hspace="4" />Print-friendly Version</a><br></td>
</tr></table></div>
</td></tr>
</table>
<!--  END VCD4 PFV -->
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr><td class="smaller" valign="top"><em>
By <a href="#author">Ed Ort and Bhakti Mehta</a>, March 2003
</em></td>
<td width="10">&nbsp;</td>
<td align="right" valign="bottom">
<div class="sitelinks" style="padding:0px;">
<table border="0" cellpadding="0" cellspacing="0">
<tr>
<!--
<td valign="bottom" align="right"><img src="/im/ic_email.gif" width="14" height="12" border="0" hspace="4" vspace="1" alt=" " /></td>
<td valign="bottom" class="smaller" nowrap="nowrap"><a href="#{link placeholder}">E-mail</a></td>
<td>&nbsp;&nbsp;</td>
<td valign="bottom" align="right">&nbsp;</td>
<td valign="bottom" class="smaller" nowrap="nowrap"><a href="/jsp_utils/PrintPage.jsp" target="printFriendlyView" onclick="openPopup('','printFriendlyView',710,650,'no',1,1,0,0,0,0); return true;"><img src="/im/ic_print.gif" width="14" height="12" alt="Print-friendly Version" border="0" hspace="4" />Print-friendly Version</a></td>
<td>&nbsp;&nbsp;</td>
<td valign="bottom" align="right"><img src="/im/ic_download_thin.gif" width="9" height="14" hspace="4" border="0" alt=" " /></td>
<td valign="bottom" class="smaller" nowrap="nowrap"><a href="#{link placeholder}">Download</a></td>
-->
</tr>
</table>
</div>
</td></tr>
</table>
<div class="contentdivider"><table border="0" cellpadding="0" cellspacing="0" width="100%" class="grey4">
<tr><td><img src="/im/a.gif" width="1" height="4" border="0" alt=" " /></td></tr></table></div>
<!--  END VCD4 BYLINE AND TOOLS  -->
<p>
<img src="/developer/technicalArticles/WebServices/jaxb/xml_schema_fig1.gif" border="0" height="300" width="450" alt="Using JAXB">
</p>
<p>
You will find the following topics covered in this article:
<ul>
<li><a href="#introjb">What's JAXB?</a></li>
<li><a href="#xmp1">An Example: Accessing an XML Document</a></li>
<ul>
<li><a href="#binsch">Bind the Schema</a></li>
<li><a href="#unmars">Unmarshal the Document</a></li>
</ul>
<li><a href="#xmp2">Another Example: Building an XML Document</a></li>
<ul>
<li><a href="#binsch2">Bind the Schema</a></li>
<li><a href="#crtree">Create the Content Tree</a></li>
<li><a href="#mars">Marshal the Content Tree</a></li>
</ul>
<li><a href="#xmp3">A Final Example: Updating an XML Document</a></li>
<li><a href="#custbind">Binding Can Be Customized</a></li>
<li><a href="#disadv">Distinct Advantages</a></li>
<li><a href="#runxmp">Run the Examples</a></li>
</ul>
</p>
<a name="introjb"></a>
<h3>What's JAXB?</h3>
<!-- SIDEBAR -->
<table align="RIGHT" bgcolor="#FFFFCC" cellpadding="5" border="1"
width="350" hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>XML and Java technology are recognized as ideal building blocks for developing 
Web services and applications that access Web services. A new Java API called 
Java Architecture for XML Binding (JAXB) can make it easier  to access XML documents 
from applications written in the Java programming language.</b>
</p>
</td>
</tr>
</font> 
</table>
<!-- END SIDEBAR -->
<p>
The <a href="http://www.w3.org/XML/">Extensible Markup Language (XML)</a> and Java technology 
are natural partners in helping developers exchange data and programs across the Internet. 
That's because XML has emerged as the standard for exchanging data across disparate systems, and 
Java technology provides a platform for building portable applications. This partnership
is particularly important for Web services, which promise users and application developers 
program functionality on demand from anywhere to anywhere on the Web. XML and Java technology 
are recognized as ideal building blocks for developing Web services and applications that 
access Web services.
</p>
<p>
But how do you couple these partners in practice? More specifically, how do you access and use 
an XML document (that is, a file containing XML-tagged data) through the Java programming language? 
One way to do this, perhaps the most typical way, is through parsers that conform to the 
<a href="http://www.saxproject.org/">Simple API for XML (SAX)</a> or the 
<a href="http://www.w3.org/DOM/">Document Object Model (DOM)</a>. Both of these parsers
are provided by <a href="/xml/jaxp/index.jsp">Java API for XML Processing (JAXP)</a>. 
Java developers can invoke a SAX or DOM parser in an application through the JAXP API to parse an 
XML document -- that is, scan the document and logically break it up into discrete pieces. 
The parsed content is then made available to the application. In the SAX approach, the parser 
starts at the beginning of the document and passes each piece of the document to the application 
in the sequence it finds it. Nothing is saved in memory. The application can take action on the data 
as it gets it from the parser, but it can't do any in-memory manipulation of the data. For example, it
can't update the data in memory and return the updated data to the XML file.   
</p>
<p>
In the DOM approach, the parser creates a tree of objects that represents the 
content and organization of data in the document. In this case, the tree exists in memory.
The application can then navigate through the tree to access the data it needs,
and if appropriate, manipulate it.
</p>
<p>
Now developers have another Java API at their disposal that can make it easier 
to access XML documents: <a href="/xml/jaxb/index.jsp">Java Architecture for XML Binding (JAXB)</a>.
A Reference Implementation of the API is now available in the 
<a href="/webservices/webservicespack.html">Java Web Services
Developer Pack V 1.1</a>.  
</p>
<p>
Let's look at JAXB in action, and compare it to SAX and DOM-based processing.
</p>
<a name="xmp1"></a>
<h3>An Example: Accessing an XML Document</h3>
<p>
Suppose you need to develop a Java application that accesses and displays
data in XML documents such as <a href="/developer/technicalArticles/WebServices/jaxb/books.txt">books.xml</a>. These documents
contain data about books, such as book name, author, description, and ISBN identification number. 
You could use the SAX or DOM approach to access an XML document and then display the data. 
For example, suppose you took the SAX approach. In that case, you would need to:
<ul>
<li>Write a program that creates a SAX parser and then uses that parser to parse the XML document. 
The SAX parser starts at the beginning of the document. When it encounters something significant 
(in SAX terms, an &quot;event&quot;) such as the start of an XML tag, or the text inside of a tag, 
it makes that data available to the calling application. 
</li> 
<p></p>
<li>Create a content handler that defines the methods to be notified by the parser when it encounters 
an event. These methods, known as callback methods, take the appropriate action on the data they receive.</li>
</ul> 
</p>
<p>
As an example, <a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXPTest1.java">here</a> is a program that uses JAXP to create and use 
a SAX parser to parse an XML document. The program uses a content handler, <code>MyContentHandler</code>, to display the data passed 
to it by the SAX parser. 
</p>
<!-- SIDEBAR -->
<table align="RIGHT" bgcolor="#FFFFCC" cellpadding="5" border="1"
width="350" hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>JAXB allows Java developers to access and process XML data without having to know XML
or XML processing. For example, there's no need to create or use a SAX parser or write
callback methods.</b>
</p>
</td>
</tr>
</font> 
</table>
<!-- END SIDEBAR -->
<p>
Now let's look at how you use JAXB to access an XML document such as <code>books.xml</code> 
and display its data. Using JAXB, you would:
<ul>
<li><a href="#binsch">Bind the schema</a> for the XML document.</li>
<p></p>
<li><a href="#unmars">Unmarshal the document</a> into Java content objects. The Java content objects represent 
the content and organization of the XML document, and are directly available to your program. 
</li>
</ul>
</p>
<p>
After unmarshalling, your program can access and display the data in the XML document simply 
by accessing the data in the Java content objects and then displaying it. 
There is no need to create and use a parser and no need to write a content handler with callback methods.
What this means is that developers can access and process XML data without having to know XML
or XML processing.  
</p>
<a name="binsch"></a>
<h4>Bind the Schema</h4>
<p>
<img src="/developer/technicalArticles/WebServices/jaxb/xml_schema_fig2.gif" border="0" height="110" width="450" alt="Binding an XML Schema">
</p>
<p>
JAXB simplifies access to an XML document from a Java program by presenting the 
XML document to the program in a Java format. The first step in this process is
to bind the schema for the XML document into a set of Java classes that represents the schema. 
<p>
<b>Schema</b>: A schema is an XML specification that
governs the allowable components of an XML document and the relationships
between the components. For example, a schema identifies the elements that can appear in an XML document, 
in what order they must appear, what attributes they can have, and which elements are subordinate 
(that is, are child elements) to other elements. An XML document does not have to have a schema, 
but if it does, it must conform to that schema to be a valid XML document. JAXB requires that the 
XML document you want to access has a schema, and that schema is written in the 
<a href="http://www.w3.org/TR/xmlschema-0">W3C XML Schema Language</a> (see the box
&quot;Why W3C XML Schema Language?&quot;). 
<p>
<p>
Assume, for this example, that the <code>books.xml</code> document 
has a schema, <a href="/developer/technicalArticles/WebServices/jaxb/bookxsd.txt">books.xsd</a>, that is written in the W3C XML Schema Language.
This schema defines a <code>&lt;Collection&gt;</code> as an element that has a complex type. This means 
that it has child elements, in this case, <code>&lt;book&gt;</code> elements. Each <code>&lt;book&gt;</code> 
element also has a complex type named <code>bookType</code>. The <code>&lt;book&gt;</code> element has child 
elements such as <code>&lt;name&gt;</code>, <code>&lt;ISBN&gt;</code>, and <code>&lt;author&gt;</code>. 
Some of these have their own child elements.
</p>
<!-- SIDEBAR -->
<table align="center" width="85%" bgcolor="#ffffcc" cellpadding="5" border="1"
hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>Why W3C XML Schema Language?</b>
</p>
<p>
<b>The W3C XML Schema Language is not the only schema language. In fact, the XML specification  
describes document-type definitions (DTDs) as the way to express a schema. In addition, 
pre-release versions of the JAXB Reference Implementation worked only with DTDs -- that is, not
with schemas written in the XML Schema Language. However, the XML Schema Language
is much richer than DTDs. For example, schemas written in the XML Schema Language
can describe structural relationships and data types that can't be expressed (or can't easily
be expressed) in DTDs. There are tools available to convert DTDs to the W3C XML Schema Language,
so if you have DTD-based schemas that you used with an earlier version of the JAXB Reference 
Implementation, you can use these tools to convert the schemas to XML Schema Language.
</b></p>
</td>
</tr>
</font>
</table>
<!-- END SIDEBAR -->
<p>
<b>Binding</b>: Binding a schema means generating a set of Java classes that represents 
the schema. All JAXB implementations provide a tool called a binding compiler to bind a schema
(the way the binding compiler is invoked can be implementation-specific). For example, the JAXB Reference 
Implementation provides a binding compiler that you can invoke through scripts. Suppose, for example,
you want to bind the <code>books.xsd</code> schema using the binding compiler
provided by the JAXB Reference Implementation. Suppose too that you're working in the 
Solaris Operating Environment. Here's a command
you can use to run the script that binds the schema:
</p>
<p>
<pre>
xjc.sh -p test.jaxb books.xsd -d work
</pre>
</p>
<p>
The <code>-p</code> option identifies a package for the generated classes,
and the <code>-d</code> option identifies a target directory. So for this command, the
classes are packaged in <code>test.jaxb</code> within the <code>work</code> directory.
</p>
<p>
In response, the binding compiler generates a set of interfaces and a set of classes
that implement the interfaces. Here are the interfaces it generates for the <code>books.xsd</code> schema:
<ul>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/CollectionType.java">CollectionType.java</a></code>. Represents the  
unnamed complex type for the <code>&lt;Collection&gt;</code> element.</li>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/Collection.java">Collection.java</a></code>. Represents the <code>&lt;Collection&gt;</code> 
element.</li>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/BookType.java">BookType.java</a></code>. Represents the <code>BookType</code> complex type.</li>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/ObjectFactory.java">ObjectFactory.java</a></code>. Contains methods for generating instances
of the interfaces.</li>
</ul>
</p>
<p>
Here are the classes that implement the interfaces (these are generated in an <code>impl</code>
subdirectory). Note that these classes are implementation-specific -- in this example, they
are specific to the Reference Implementation. Because the classes are implementation-specific,
classes generated by the binding compiler in one JAXB implementation will probably not work with 
another JAXB implementation. So if you change to another JAXB implementation, you should rebind the 
schema with the binding compiler provided by that implementation.
</p>
<p>
<ul>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/CollectionTypeImpl.java">impl/CollectionTypeImpl.java</a></code>. Implements the 
<code>CollectionType</code> interface described in <code>CollectionType.java</code>.</li>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/CollectionImpl.java">impl/CollectionImpl.java</a></code>. Implements the 
<code>Collection</code> interface described in <code>Collection.java</code>.</li>
<li><code><a href="/developer/technicalArticles/WebServices/jaxb/BookTypeImpl.java">impl/BookTypeImpl.java</a></code>. Implements the 
<code>BookType</code> interface described in <code>BookType.java</code>.</li>
</ul>
</p>
<p>
In total, the generated classes represent the entire <code>books.xsd</code> schema. 
Notice that the classes define <code>get</code> and <code>set</code>methods
that are used to respectively obtain and specify data for each type of element and attribute
in the schema. 
</p>
<p>
You then compile the generated interfaces and classes. For example:
<p>
<p>
<pre>
javac test/jaxb/*.java  test/jaxb/impl/*.java
</pre>
</p>
<p>
This compiles all of the interfaces and classes in the <code>test.jaxb</code> package generated by the binding compiler.
</p>
<a name="unmars"></a>
<h4>Unmarshal the Document</h4>
<p>
<img src="/developer/technicalArticles/WebServices/jaxb/xml_schema_fig3.gif" border="0" height="168" width="450" alt="Unmarshalling">
</p>
<p>
Unmarshalling an XML document means creating a tree of content objects that represents the content and
organization of the document. The content tree is not a DOM-based tree. In fact, content trees
produced through JAXB can be more efficient in terms of memory use than DOM-based trees. 
</p>
<p>
The content objects are instances of the classes produced by the binding compiler. 
In addition to providing a binding compiler, a JAXB implementation must provide runtime APIs for JAXB-related 
operations such as marshalling. The APIs are provided as part of a binding framework. 
The binding framework comprises three packages. The primary package, <code>javax.xml.bind</code>,
contains classes and interfaces for performing operations such as unmarshalling, marshalling, and validation
(marshalling and validation will be covered later).
A second package, <code>javax.xml.bind.util</code>, contains a number of utility classes.
The third package, <code>javax.xml.bind.helper</code>, is designed for JAXB implementation
providers. 
</p>
<p>
To unmarshal an XML document, you:
</p>
<ul>
<li>Create a <code>JAXBContext</code> object. This object provides the entry point to the
JAXB API. When you create the object, you need to specify a context path. 
This is a list of one or more package names that contain interfaces generated by the binding compiler. 
By allowing multiple package names in the context path, JAXB allows you to unmarshal a combination of
XML data elements that correspond to different schemas. 
<br><br>
For example, the following code snippet creates a <code>JAXBContext</code> object whose context path is <code>test.jaxb</code>, the package that contains the interfaces generated for the <code>books.xsd</code> schema:
<pre>

import javax.xml.bind.JAXBContext;

JAXBContext jc = JAXBContext.newInstance(&quot;test.jaxb&quot;);
</pre>
</li>
<li>Create an <code>Unmarshaller</code> object. This object controls the process of unmarshalling.
In particular, it contains methods that perform the actual unmarshalling operation. For example, 
the following code snippet creates an <code>Unmarshaller</code> object:
<pre>
import javax.xml.bind.Unmarshaller;

Unmarshaller unmarshaller = jc.createUnmarshaller();
</pre>
</li>
<li>Call the <code>unmarshal</code> method. This method does the actual unmarshalling of the XML document.
For example, the following statement unmarshals the XML data in the <code>books.xml</code> file:
<pre>
Collection collection= (Collection)
    unmarshaller.unmarshal(new File( &quot;books.xml&quot;));
</pre>
Note that a <code>Collection</code> here is a <code>test.jaxb.Collection</code>, 
not a <code>java.util.Collection</code>.
</li>
<br><br>
<li>Use the <code>get</code> methods in the schema-derived classes to access the XML data. 
Recall that the classes that a JAXB compiler generates for a schema include <code>get</code>
and <code>set</code> methods you can use to respectively obtain and specify data for each 
type of element and attribute in the schema. 
For example, the following statement gets the data
in the <code>books</code> and <code>book</code> elements:
<pre>
CollectionType.BooksType booksType = collection.getBooks();
List bookList = booksType.getBook();
</pre>
</li>
</ul>
<p>
After obtaining the data, you can display it directly from your program. Here, for example, is 
a <a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXBTest1.java">program</a> that unmarshals the data in the <code>books.xml</code> file 
and then displays the data. If you run the program, you should see the following result:
</p>
<p>
<!-- BEGIN VCD7 CODE SAMPLE COMPONENT  -->
<table border="0" cellpadding="10" cellspacing="0" width="100%" class="grey4">
<tr><td><pre>
Book  details 
Item id: 999
Book Name: Learning JAXB
Book ISBN: 123445
Book Price: 34 $
Book category: other
Book promotion: 10% on this book if purchased by March 2003
No of Authors 1
Author Name Jane Doe

Book  details 
Item id: 129
Book Name: Java Webservices today and Beyond
Book ISBN: 522965
Book Price: 29 $
Book category: magazine
Book promotion: Buy one get Learning webservices Part 1 free
No of Authors 2
Author Name John Brown
Author Name Peter T.
</pre></td></tr></table>
<span class="sp20"> </span><br />
<!-- END VCD7 CODE SAMPLE COMPONENT  -->
</p>
<p>
<b>Validating the Source Data</b>: Notice that the program includes the following statement:
</p>
<p>
<pre>

unmarshaller.setValidating(true);
</pre>
</p>
<!-- SIDEBAR -->
<table align="RIGHT" bgcolor="#FFFFCC" cellpadding="5" border="1"
width="350" hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>You can validate source data against an associated schema as part of the unmarshalling operation.</b>
</p>
</td>
</tr>
</font>
</table>
<!-- END SIDEBAR -->
<p>
This statement highlights an important feature of JAXB: you can have it validate the source data
against the associated schema as part of the unmarshalling operation. In this case, the statement 
asks JAXB to validate the source data against its schema. If the data is found to be invalid (that is, 
it doesn't conform to the schema) the JAXB implementation can report it and might take further action. 
JAXB providers have a lot of flexibility here. The JAXB specification mandates that all 
provider implementations report validation errors when the errors are encountered, but the implementation 
does not have to stop processing the data. Some provider implementations might stop processing when the 
first error is found, others might stop even if many errors are found. In other words, it is possible 
for a JAXB implementation to successfully unmarshal an invalid XML document, and build a Java content tree.
However, the result won't be valid. The main requirement is that all JAXB implementations must be able to 
unmarshal valid documents.
</p>
<p>
You also have the flexibility of turning the validation switch off if you 
don't want to incur the additional validation processing overhead.
</p>
<p>
<b>Unmarshalling Other Sources</b>: Although the example described in this section shows how to 
unmarshal XML data in a file, you can unmarshal XML data from other input sources such as 
an <code>InputStream object</code>, a URL, or a DOM node. You can even unmarshal transformed 
XML data. For example, you can unmarshal a <code>javax.xml.transform.sax.SAXSource</code> object.
You can also unmarshal SAX events -- in other words, you can do a SAX parse of a document
and then pass the events to JAXB for unmarshalling.
<p>
<b>An Alternative: Accessing Data without Unmarshalling</b>: JAXB also allows you to access 
XML data without having to unmarshal it. One of the classes generated from a schema, <code>ObjectFactory</code>,
contains methods to generate objects for each of the schema-derived interfaces and classes. 
For example, the package generated for the <code>books.xsd</code> schema includes
an <code>ObjectFactory</code> class that has methods such as <code>createCollection</code> to create
a <code>Collection</code> object, and <code>createBookType</code> to create a <code>BookType</code> object.
You can use these methods to create a tree of content objects without doing
any unmarshalling. All your program needs is access to the <code>ObjectFactory</code> class 
that's in the package for the pertinent schema. Then you can use the appropriate methods
in the <code>ObjectFactory</code> class to create the objects you need. After you create the objects,
you need to provide their content. To do that, you use the <code>set</code> methods in the objects. 
</p>
<a name="xmp2"></a>
<h3>Another Example: Building an XML Document</h3>
<p>
Instead of accessing data in an XML document, suppose you need to build an XML document
through a Java application. Here too using JAXB is easier. Let's investigate.
</p>
<p>You could use the DOM approach to build an XML document, but not SAX. That's because you would need to build and populate the content of 
the document in memory -- recall that SAX does not allow you to perform any in-memory manipulation of data. 
Using the DOM approach, your program needs to create and use DOM objects and methods to build the document. DOM is designed to 
represent the content and organization of data in a document as a tree of objects. To build the document, 
your program uses DOM to create a <code>Document</code> object that represents the document. Your program 
then uses <code>Document</code> object methods to create other objects that represent the nodes of the tree. 
Each node contains content for the XML document. You then append the nodes in an order that reflects 
the organization of the tree. In other words, your program uses DOM object methods to create a root node, 
and append  the root node to the <code>Document</code> object. Then it creates child nodes and appends them 
to the root node. If a child node has children of its own, your program uses DOM object methods to create 
those nodes and append them to their parent node.  
</p>
<p>
Unlike the SAX approach, there is no need in DOM to write a content handler and callback methods.
However the DOM approach requires you to understand the organization of the document tree.
In fact, if you use DOM to access data, you create a parser that builds a tree, and then
you use DOM methods to navigate to the appropriate object in the tree that contains the data you need.
So an understanding of the tree's organization is a requirement. Compare this to JAXB, where you have 
direct access to unmarshalled XML data through objects in the content tree. As in DOM-based processing, 
JAXB allows access to data in non-sequential order, 
but it doesn't force an application to navigate through a tree to access the data.
In addition, with all the creating and appending of objects that represent the nodes of the tree, 
the DOM approach can be tedious.
</p>
<p>
<a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXPTest2.java">Here</a>, for example, is a program that uses DOM to 
build and populate a document, and then write the document to an XML file. Notice
that the type of data that gets populated into the document is similar to the data in the 
<code>books.xml</code> file that was used in the first example, 
<a href="#xmp1">Accessing an XML Document</a>. In fact, the program validates the document 
it builds against the <a href="/developer/technicalArticles/WebServices/jaxb/bookxsd.txt">books.xsd</a> schema that was used in the first example.
</p>
<table align="RIGHT" bgcolor="#FFFFCC" cellpadding="5" border="1"
width="350" hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>As in DOM-based processing, JAXB allows access to data in non-sequential order, 
but it doesn't force an application to navigate through a tree to access the data.</b>
</p>
</font>
</td>
</tr>
</table>
<!-- END SIDEBAR -->
<p>
Now let's look at how you use JAXB to build the same document, validate it against the <code>books.xsd</code> schema,
and write the document to an XML file. Using JAXB, you would:
<ul>
<li><a href="#binsch2">Bind the schema</a> for the XML document (if it isn't already bound).
</li>
<p></p>
<li><a href="#crtree">Create the content tree</a>. 
</li>
<p></p>
<li><a href="#mars">Marshal the content tree</a> into the XML document. 
</li>
</ul>
</p>
<p>
In this process, you don't deal with the intricacies of the DOM object model or even need
to know XML. 
</p>
<a name="binsch2"></a>
<h4>Bind the Schema</h4>
<p>
This is the <a href="#binsch">same operation</a> you perform prior to unmarshalling a document.
In this case, the schema is for the XML document you want to build. Of course, if you've
already bound the schema (for instance, you unmarshalled an XML document, updated the
data, and now want to write the updated data back to the XML document), you don't have to bind the 
schema again.
</p>
<a name="crtree"></a>
<h4>Create the Content Tree</h4>
<p>
The content tree represents the content that you want to build into the XML document. You can create
the content tree by unmarshalling XML data, or you can create it using the <code>ObjectFactory</code>
class that's generated by binding the appropriate schema. Let's use the <code>ObjectFactory</code> approach.
First, create an instance of the <code>ObjectFactory</code> class:
</p>
<p>
<pre>
ObjectFactory objFactory = new ObjectFactory();
</pre>
</p>
<p>Next, use <code>create</code> methods in the <code>ObjectFactory</code> object to create each of the objects 
in the content tree. For example: 
</p>
<p>
<!-- BEGIN VCD7 CODE SAMPLE COMPONENT  -->
<table border="0" cellpadding="10" cellspacing="0" width="100%" class="grey4">
<tr><td><pre>
Collection collection= 
   (Collection) objFactory.createCollection();
Collection.BooksType booksType = objFactory.
   createCollectionTypeBooksType();
BookType book = objFactory.createBookType();   
</pre></td></tr></table>
<span class="sp20"> </span><br />
<!-- END VCD7 CODE SAMPLE COMPONENT  -->
</p>
<p>
Then use <code>set</code> methods in the created objects to specify data values. For example:
</p>
<p>
<pre>
book.setItemId(&quot;307&quot;);
book.setName(&quot;JAXB today and beyond&quot;); 
</pre>
</p>
<a name="mars"></a>
<h4>Marshal the Content Tree</h4>
<p>
<img src="/developer/technicalArticles/WebServices/jaxb/xml_schema_fig4.gif" border="0" height="168" width="450" alt="Marshalling">
</p>
<p>
Marshalling is the opposite of unmarshalling. It creates an XML document from a content tree.
To marshal a content tree, you:
<ul>
<li>Create a <code>JAXBContext</code> object, and specify the appropriate context path -- that is, the package 
that contains the classes and interfaces for the bound schema. As is the case for unmarshalling, you can
specify multiple package names in the context path. That gives you a way of building an XML document
using a combination of XML data elements that correspond to different schemas. 
<pre>
import javax.xml.bind.JAXBContext;

JAXBContext jaxbContext = JAXBContext.newInstance(&quot;test.jaxb&quot;);
</pre>
</li>
<li>Create a <code>Marshaller</code> object. This object controls the process of marshalling.
In particular, it contains methods that perform the actual marshalling operation. 
<pre>
import javax.xml.bind.Marshaller;

Marshaller marshaller = jaxbContext.createMarshaller();

</pre>
The <code>Marshaller</code> object has properties that you can set through the <code>setProperty</code>
method. For example, you can specify the output encoding to be used when marshalling the XML data.
Or you can tell the <code>Marshaller</code> to format the resulting XML data with line breaks and 
indentation. The following statement turns this output format property on -- line breaks and indentation 
will appear in the output format: 
<pre>
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT,
   new Boolean(true));
</pre>
</li>
<li>Call the <code>marshal</code> method. This method does the actual marshalling of the content tree.
When you call the method, you specify an object that contains the root of the content tree,
and the output target. For example, the following statement marshals the content tree whose root
is in the <code>collection</code> object and writes it as an output stream to the XML file <code>jaxbOutput.xml</code>:
<pre>
marshaller.marshal(collection,
   new FileOutputStream("jaxbOutput.xml"));
</pre>
</li>
</ul>
<p>
Here, for example, is a <a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXBTest2.java">program</a> that creates a content tree, fills it
with data, and then marshals the content tree to an XML file.
<p>
<b>Validating the Content Tree</b>: Notice that validation is not performed as part of the 
marshalling operation. In other words,
unlike the case for unmarshalling, there is no <code>setValidating</code> method for  
marshalling. Instead, when marshalling data, you use the <code>Validator</code>
class that is a part of the binding framework to validate a content tree against a schema. For example:
</p>
<p>
<pre>
import javax.xml.bind.Validator;

Validator validator = jaxbContext.createValidator();
validator.validate(collection));
</pre>
</p>
<p>
Validating the data as a separate operation from marshalling gives you a lot of flexibility.
For example, you can do the validating at one point in time, and do the marshalling at another time.
Or you can do some additional processing in between the two operations. Note that the JAXB specification 
doesn't require a content tree to be valid before it's marshalled. That doesn't necessarily mean that 
a JAXB implementation will allow invalid data to be marshalled -- it might marshal part or all of the 
invalid data, or not. But all JAXB implementations must be able to marshal valid data. 
</p>
<p>
<b>Marshalling to Other Targets</b>: Although the example described in this section shows how to marshal 
data to an XML file, you can marshal to other output formats such as an 
<code>OutputStream</code> object or a DOM node. You can also marshal to a transformed data format 
such as <code>javax.xml.transform.SAXResult</code>. You can even marshal to a content handler.
This allows you to process the data as SAX events.
</p>
<a name="xmp3"></a>
<h3>A Final Example: Updating an XML Document</h3>
<p>Here's a final example, one that logically combines elements of accessing an XML document
and building an XML document. Suppose you need to update an XML document. In the DOM approach,
you would create and use a DOM parser to navigate to the appropriate object in the tree 
that contains the data you need, update the data, and then write the updated data to an XML file.
Here, for example, is a <a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXPTest3.java">program</a> that uses DOM to update an XML document.
As discussed in <a href="#xmp2">Building an XML Document</a>, the DOM approach is relatively tedious 
and forces you to know the organization of the content tree. 
</p>
<p>
Here, by comparison, is a <a href="/developer/technicalArticles/WebServices/jaxb/UsingJAXBTest3.java">JAXB program</a> that updates
an XML document. Specifically, it updates an unmarshalled content tree and then marshals it back 
to an XML document.
Notice how JAXB simplifies the process. The program has direct access to the object it needs to update.
The program uses a <code>get</code> method to access the data it needs, and a
<code>set</code> method to update the data.
</p> 
<p>
Although it's tempting to think that the XML data can make a &quot;roundtrip&quot; unchanged,
there's no guarantee of that. In other words, if you use JAXB to unmarshal an XML document and then
marshal it back to the same XML file, there's no guarantee that the XML document will look exactly
the same at it did originally. For example, the indentation of the resulting XML document might
be a bit different than the original. The JAXB specification does not require the preservation of
the XML information set in a roundtrip from XML document-to-Java representation-to XML document.
But it also doesn't forbid the preserving of it.
</p> 
<a name="custbind"></a>
<h3>Binding Can Be Customized</h3>
<!-- SIDEBAR -->
<table align="RIGHT" bgcolor="#FFFFCC" cellpadding="5" border="1"
width="350" hspace="3" vspace="3">
<font size="-1">
<tr>
<td> 
<p>
<b>The JAXB specification describes the default behavior for binding a subset of XML schema
components to Java components. However JAXB allows you to annotate a schema with binding declarations 
that override or extend the default binding behavior.</b>
</p>
</td>
</tr>
</font>
</table>
<!-- END SIDEBAR -->
<p>
The JAXB specification describes the default behavior for binding a subset of XML schema
components to Java components. The specification identifies which XML schema components must be
bound and to what Java representations these components are bound. For example,
the XML built-in datatype <code>xsd:string</code> must be bound to the Java data type 
<code>java.lang.String</code>. All JAXB compiler implementations must implement
the default binding specifications.
However there are times when the default behavior might not be what you want.
For example, suppose you want an XML data type mapped to a Java data type
that is different than the type called for by the default binding specification.
Or you want the binding compiler to assign a name of your choice to a class that it generates.
</p>
<p>
To meet these and other customization needs, JAXB allows you to annotate 
a schema with binding declarations that override or extend the default binding behavior.
JAXB allows these declarations to be made &quot;inline&quot; -- that is, 
in the schema, or in a separate document. 
</p>
<p>
Let's look at a customization example. <a href="/developer/technicalArticles/WebServices/jaxb/bookxsdcust.txt">Here</a> is an annotated
version of the <code>books.xsd</code> schema that was used in the previous examples.
The annotations in this example are inline. 
<p>
<p>
Notice the <code>annotation</code> element near the top of the schema:
</p>
<p>
<!-- BEGIN VCD7 CODE SAMPLE COMPONENT  -->
<table border="0" cellpadding="10" cellspacing="0" width="100%" class="grey4">
<tr><td><pre>
&lt;xs:annotation&gt;
   &lt;xs:appinfo&gt;
      &lt;jaxb:globalBindings generateIsSetMethod=&quot;true&quot;&gt;

      bindingStyle=&quot;modelGroupBinding&quot;
         choiceContentProperty=&quot;true&quot; &gt;
         
           &lt;xjc:serializable uid=&quot;12343&quot;/&gt;
           &lt;jaxb:javaType name=&quot;short&quot; 
              xmlType=&quot;xs:long&quot; 
              printMethod=&quot;javax.xml.bind.DatatypeConverter.printShort&quot;   
              parseMethod=&quot;javax.xml.bind.DatatypeConverter.parseShort&quot;/&gt;

      &lt;/jaxb:globalBindings&gt;
   &lt;/xs:appinfo&gt;
&lt;/xs:annotation&gt;
</pre></td></tr></table>
<span class="sp20"> </span><br />
<!-- END VCD7 CODE SAMPLE COMPONENT  -->
</p> 
<p>
All binding declarations are in an <code>annotation</code>
element and its subordinate <code>appinfo</code> element. In fact, all inline
binding declarations must be made this way.
</p>
<p>
This block of code demonstrates a number of customizations that you can make to a schema:
</p>
<p>
<b>Make global customizations</b>: The <code>&lt;jaxb:globalBindings ...&gt;</code> element specifies
binding declarations that have global scope. In JAXB, 
binding declarations can be specified at different levels, or &quot;scopes.&quot; Each scope 
inherits from the scopes above it, and binding declarations in a scope override binding declarations 
in scopes above it. Global scope is at the top of the scope hierarchy. It covers all the
schema elements in the source schema and (recursively) any schemas that are included or imported
by the source schema. Global scope is followed in the hierarchy by Schema scope 
(covers all the schema elements in the target namespace of a schema), Definition scope (covers all 
schema elements that reference a specified type definition or a global declaration), and Component 
scope (applies only to a specific schema element that was annotated with a binding declaration).
</p>
<p>
Notice that the namespace prefix (<code>jaxb</code>) for the <code>&lt;globalBindings&gt;</code> element is bound 
to http://java.sun.com/xml/ns/jaxb. This URI contains the core schema for binding declarations.
</p>
<p>
<b>Add method signatures</b>. The declaration <code>generateIsSetMethod=&quot;true&quot;</code> 
tells the binding compiler to generate <code>isSet</code> methods for the properties 
of all generated classes. These methods are used to determine if a property in a class is set 
or has a default value.
</p>
<p>
<b>Change binding style</b>. By default, schema components that have complex
types and that have a content type property of mixed or element-only are bound with a style
called element binding. In element binding, each element in the complex type is mapped
to a unique content property. Alternatively, you can change the binding style to 
model group binding by specifying <code>bindingStyle=&quot;modelGroupBinding&quot;
choiceContentProperty=&quot;true&quot;</code>. In model group binding, schema components
that have complex type and that are nested in the schema are mapped to Java interfaces.
This gives users a way to specifically customize these nested components. 
For example, the following component is nested in the customized schema:
</p>
<p>
<!-- BEGIN VCD7 CODE SAMPLE COMPONENT  -->
<table border="0" cellpadding="10" cellspacing="0" width="100%" class="grey4">
<tr><td><pre>
&lt;xs:element name=&quot;promotion&quot;&gt;

       &lt;xs:complexType&gt;
         &lt;xs:choice&gt;
           &lt;xs:element name=&quot;Discount&quot; type=&quot;xs:string&quot; /&gt;
           &lt;xs:element name=&quot;None&quot; type=&quot;xs:string&quot;/&gt;

         &lt;/xs:choice&gt;
       &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
</pre></td></tr></table>
<span class="sp20"> </span><br />
<!-- END VCD7 CODE SAMPLE COMPONENT  -->
</p>
<p>
As result of the global declarations made earlier, the binding compiler will generate
the following methods for the elements tagged as <code>choice</code>:
</p>
<p>
<pre>
java.lang.Object getDiscountOrNone();
void setDiscountOrNone(java.lang.Object value);
boolean is SetDiscountOrNone();
</pre>
</p>
<p>
<b>Include vendor-specific extensions</b>. The declaration 
<code>&lt;xjc:serializable uid=&quot;12343&quot;/&gt;</code> is an
extension binding declaration. The <code>xjc</code> prefix binds to a namespace 
for extension binding declarations. These declarations are vendor-specific extensions
to the binding declarations defined in http://java.sun.com/xml/ns/jaxb. 
Here, the vendor-specific declaration covers the binding of classes that implement
<code>java.io.Serializable</code>. The serial version uid 12343 will be assigned to each 
generated class.
</p>
<p>
<b>Customize the binding of a simple data type</b>. The
declaration <code>&lt;jaxb:javaType name=&quot;short&quot; xmlType=&quot;xs:long&quot;</code>
binds the XML datatype <code>xs:long</code> to the Java data type
<code>short</code>. This overrides the default binding behavior, which is
to bind <code>xs:long</code> to the Java primitive data type <code>long</code>.
The additional declaration 
<code>printMethod=&quot;javax.xml.bind.DatatypeConverter.parseShort&quot;</code>
tells the binding compiler to use the <code>DatatypeConverter.parseShort</code> method 
in JAXB's <code>javax.xml.bind</code> package to convert a lexical representation
of the XML data type into the Java data type. The parse method is invoked by the
JAXB provider's implementation during unmarshalling.
The additional declaration 
<code>printMethod=&quot;javax.xml.bind.DatatypeConverter.printShort&quot;</code>
tells the binding compiler to use the <code>DatatypeConverter.printShort</code> method 
in JAXB's <code>javax.xml.bin</code> package to convert the Java data type into
a lexical representation of the XML data type. The print method is invoked by the
JAXB provider's implementation during marshalling.
</p>
<p>
<b>Additional customizations</b>: Other annotations in the schema illustrate additional types of
customization, such as annotating a specific schema element to a Java Content Interface or 
Java Element Interface. This is done through a <code>&lt;class&gt;</code> binding
declaration. In the annotated schema example, a <code>&lt;class&gt;</code> binding
declaration is used to specify the name <code>MyCollection</code> for the interface
bound to the <code>&lt;Collection&gt;</code> class. Another binding declaration
in the annotated schema example binds the <code>&lt;bookCategory&gt;</code> element
to its Java representation as a typesafe enumeration class. Although not illustrated 
in the annotated schema, another type of customization you can make is to specify javadoc 
for a generated package or class. These are only some of the many binding customizations that 
JAXB allows.
</p>
<p>
You can see the impact of the binding declarations by binding the annotated schema. 
When you do the binding, specify the <code>-extension</code> option, as
in the following command:
</p>
<p>
<pre>
xjc.sh -extension -p cust books_customization.xsd
</pre>
<p>
<p>
The <code>-extension</code> option allows you to use vendor-provided extensions.
You need this to enable the extension binding declaration in the schema. If you don't
specify the <code>-extension</code> option, the binding compiler will run in &quot;strict&quot; mode. 
In this mode, it allows only for default bindings, and will produce an error
message when it comes to the extension binding declaration.
</p>
<p>
After you run the program, examine the interfaces and classes that
the binding compiler generates, and compare them to the interfaces and classes
generated from the uncustomized schema. For example, 
<a href="/developer/technicalArticles/WebServices/jaxb/CollectionTypeCust.java">here</a> is the <code>CollectionType.java</code> 
file generated for the unnamed complex type for the <code>&lt;Collection&gt;</code> element.
Notice the additional methods that have been added because of the binding customizations. 
</p>
<a name="disadv"></a>
<h3>Distinct Advantages</h3>
<p>
Let's reiterate a number of important advantages of using JAXB:
<ul>
<li>JAXB simplifies access to an XML document from a Java program:</li>.
<ul>
<li>JAXB allows you to access and process XML data without having to know XML
or XML processing. Unlike SAX-based processing, there's no need to create a SAX parser or 
write callback methods.</li>
<li>JAXB allows you to access data in non-sequential order, but unlike
DOM-based processing, it doesn't force you to navigate through a tree to access the data.</li>
<li>By unmarshalling XML data through JAXB, Java content objects that represent the 
content and organization of the data are directly available to your program.</li>
</ul>
<li>JAXB uses memory efficiently: The tree of content objects produced through JAXB tends 
can be more efficient in terms of memory use than DOM-based trees.</li>
<li>JAXB is flexible:
<ul>
<li>You can unmarshal XML data from a variety of input sources, including a file, 
an <code>InputStream</code> object, a URL, a DOM node, or a transformed source object.
<li>You can marshal a content tree to a variety of output targets, including an XML file,
an <code>OutputStream</code> object, a DOM node, or a transformed data object</li>
<li>You can unmarshal SAX events -- for example, you can do a SAX parse of a document
and then pass the events to JAXB for unmarshalling.</li>
<li>JAXB allows you to access XML data without having to unmarshal it. Once a schema is bound
you can use the <code>ObjectFactory</code> methods to create the objects and then use <code>set</code> 
methods in the generated objects to create content.</li>
<li>You can validate source data against an associated schema as part of the unmarshalling operation,
but you can turn validation off if you don't want to incur the additional validation overhead.</li>
<li>You can validate a content tree, using the <code>Validator</code> class, separately from marshalling.
For example, you can do the validating at one point in time, and do the marshalling at another time.</li>
</ul>
<li>JAXB's binding behavior can be customized in a variety of ways.</li>
</ul>
<p>
Java developers should find JAXB a welcome aid in developing Web services 
and other Java-XML applications.
</p>
<a name="runxmp"></a>
<h3>Run the Examples</h3>
<p>
If you'd like to run the examples in this article with Java Web Services
Developer Pack V 1.1, you need to:
</p>
<p>
<ol>
<li>Install Java Web Services Developer Pack V 1.1 (if you haven't already done so).</li>
<br><br>
<li>Set the <code>JWSDP_HOME</code> environment variable to the Java Web Services Developer Pack V 1.1
installation directory. For example, if you're using the C shell in the Solaris Operating 
Environment, enter the command:
<pre>
setenv JWSDP_HOME install_dir
</pre>
replace <i>install_dir</i> with the Java Web Services Developer Pack V 1.1 installation directory.
<br><br>
</li>
<li>Set the class paths for JAXB, JAXP, and Java Web Services Developer Pack V 1.1. For example, 
if you're using the C shell in the Solaris Operating Environment, enter the commands:
<pre>
setenv jaxb_lib $JWSDP_HOME/jaxb-1.0/lib
setenv jaxp_lib $JWSDP_HOME/jaxp-1.2.2/lib/endorsed
setenv jwsdp_lib $JWSDP_HOME/jwsdp-shared/lib
</pre>
and on one line:
<!-- BEGIN VCD7 CODE SAMPLE COMPONENT  -->
<table border="0" cellpadding="10" cellspacing="0" width="100%" class="grey4">
<tr><td><pre>
setenv CLASSPATH  $jwsdp_lib/jax-qname.jar:
$jwsdp_lib/namespace.jar:$jaxb_lib/jaxb-api.jar:
$jaxb_lib/jaxb-libs.jar:$jaxb_lib/jaxb-ri.jar:
$jaxb_lib/jaxb-xjc.jar:
$jaxp_lib/dom.jar:$jaxp_lib/sax.jar:
$jaxp_lib/xalan.jar:$jaxp_lib/xercesImpl.jar:
$jaxp_lib/xsltc.jar:$jaxp_lib/../jaxp-api.jar:
.:classes:work
</pre></td></tr></table>
<span class="sp20"> </span><br />
<!-- END VCD7 CODE SAMPLE COMPONENT  -->
</li>
<li>Set the path for JAXB. For example, 
if you're using the C shell in the Solaris Operating Environment, enter the command:
<pre>
setenv PATH $JWSDP_HOME/jaxb-1.0/bin:$PATH
</pre>
</li>
</ol>
<h3>For More Information</h3>
<p>
<a href="/xml/jaxb/index.jsp">Java Architecture for XML Binding (JAXB)</a>
</p>
<p>
<a href="/webservices/webservicespack.html">Java Web Services
Developer Pack V 1.1</a>
</p>
<p>
<a href="http://www.w3.org/TR/xmlschema-0">W3C XML Schema Language</a>
</p>
<a name="author"></a>
<h3>About the Authors</h3>
<p>
<b><strong>Ed Ort</strong> </b> is a java.sun.com staff member.
He has written extensively about Java technology and Web services.</p>
<p>
<b><strong>Bhakti Mehta</strong> </b> is a Member of Technical Staff at Sun Microsystems Inc. 
She is in the Web Technologies and Standards Interoperability and Quality team, and has worked 
with JAXP, JAXB, JAXR and JAXM.</p>
<p>
Have a question about programming? Use 
<a 
href="/developer/support/index.html">Java Online 
Support.</a></p>
<!-- =================== -->
<!-- END OF MAIN CONTENT -->
<!-- =================== -->
<!--stopindex-->
<!-- END CENTRAL COLUMN COMPONENTS -->
</td><td valign="top">
<!-- BEGIN RIGHT COLUMN COMPONENTS -->
<!-- END RIGHT COLUMN COMPONENTS -->
</td></tr>
<!-- BEGIN SPACER ROW -->
<tr><td><img src="/im/a.gif" width="560" height="1" border="0" alt=" " /></td><td><img src="/im/a.gif" width="170" height="1" border="0" alt=" " /></td></tr>
<!-- END SPACER ROW -->
</table>
<!-- END WRAPPER TABLE, 2 COLUMN, MAIN/RIGHT -->
<!-- BEGIN VNV5 FOOTER  -->
<table border="0" cellpadding="0" cellspacing="10" width="100%">
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" width="100%" class="vatop">
<tr>
<td colspan="4" valign="top" class="grey3"><img src="/im/a.gif" width="1" height="2" border="0" alt="" /></td></tr>
<tr>
<td><img src="/im/a.gif" width="190" height="1" border="0" alt="" /><br />
<a href="http://www.sun.com"><img src="/im/logo_sun_small_sdn.gif" width="61" height="29" border="0" alt="" vspace="5"/></a></td>
<td width="100%" valign="top"><img src="/im/a.gif" width="350" height="1" border="0" alt="" /><br />
<div class="footer">
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910015">About Sun</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910010">About This Site</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910025">Newsletters</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/contact/index.jsp">Contact Us</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910014">Employment</a><br />
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910012">How to Buy</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910009">Licensing</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910013">Terms of Use</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910016">Privacy</a> &nbsp;|&nbsp;
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910017">Trademarks</a>
<br /><span class="sp10">&nbsp;</span><br />
<br /><span class="sp10">&nbsp;</span><br />
Copyright 1994-2005 Sun Microsystems, Inc.
</div></td>
<td><img src="/im/a.gif" width="40" height="1" border="0" alt="" /></td>
<td valign="top"><div class="footer"><b><a href="http://developers.sun.com/dispatcher.jsp?uid=6910010">A Sun Developer Network Site</a></b></div>
<div class="footer">
<img src="/im/a.gif" width="170" height="1" border="0" alt="" /><br />
Unless otherwise licensed, code in all technical manuals herein (including articles, FAQs, samples) is provided under this <a href="http://developers.sun.com/dispatcher.jsp?uid=6910008">License</a>.
<br /><span class="sp5">&nbsp;</span><br />
<a href="http://developers.sun.com/dispatcher.jsp?uid=6910006"><img src="/im/button_xml.gif" width="36" height="14" align="top" border="0" alt="XML" /></a>&nbsp;<a href="http://developers.sun.com/dispatcher.jsp?uid=6910007">Content Feeds</a>
</div></td></tr>
<tr><td colspan="4" valign="top" class="grey3"><img src="/im/a.gif" width="1" height="2" border="0" alt="" /></td></tr>
</table>
</td></tr>
</table>
<!-- END VNV5 FOOTER -->
</body>
<script language="JavaScript" src="/js/omi/jsc/s_code_remote.js"></script></html>



